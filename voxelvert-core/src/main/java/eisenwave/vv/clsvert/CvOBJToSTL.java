package eisenwave.vv.clsvert;

import eisenwave.torrens.object.BoundingBox6f;
import eisenwave.torrens.object.Vertex3f;
import eisenwave.torrens.stl.STLModel;
import eisenwave.torrens.stl.STLTriangle;
import eisenwave.torrens.wavefront.OBJFace;
import eisenwave.torrens.wavefront.OBJModel;
import eisenwave.torrens.wavefront.OBJTriplet;
import org.jetbrains.annotations.NotNull;

public class CvOBJToSTL implements Classverter<OBJModel, STLModel> {
    
    @Override
    public Class<OBJModel> getFrom() {
        return OBJModel.class;
    }
    
    @Override
    public Class<STLModel> getTo() {
        return STLModel.class;
    }
    
    @Override
    public STLModel invoke(@NotNull OBJModel obj, @NotNull Object... args) {
        return invoke(obj);
    }
    
    public STLModel invoke(OBJModel obj) {
        BoundingBox6f bounds = obj.getBoundaries();
        Vertex3f translation = bounds.getCenter().negative();
        //System.out.println(bounds+" -> "+bounds.translate(translation.getX(), translation.getY(), translation.getZ()));
        
        STLModel result = new STLModel();
        result.setHeader("Generated by VoxelVert from Wavefront");
        
        obj.forEachFace(face -> {
            for (OBJFace triangle : tessellate(face)) {
                STLTriangle stlTriangle = toTriangle(
                    obj,
                    translation,
                    triangle.getTriplet(0),
                    triangle.getTriplet(1),
                    triangle.getTriplet(2));
                
                result.add(stlTriangle);
            }
        });
        
        return result;
    }
    
    @NotNull
    private static STLTriangle toTriangle(OBJModel obj, Vertex3f t, OBJTriplet a, OBJTriplet b, OBJTriplet c) {
        Vertex3f
            va = obj.getVertex(a.getVertexIndex()),
            vb = obj.getVertex(b.getVertexIndex()),
            vc = obj.getVertex(c.getVertexIndex());
        
        final Vertex3f n;
        {
            int
                naIndex = a.getNormalIndex(),
                nbIndex = b.getNormalIndex(),
                ncIndex = c.getNormalIndex();
            
            if (naIndex > 0 && nbIndex > 0 && ncIndex > 0) {
                // create face normal from vertex normals
                Vertex3f
                    na = obj.getNormal(naIndex),
                    nb = obj.getNormal(nbIndex),
                    nc = obj.getNormal(ncIndex);
                
                n = na.plus(nb).plus(nc);
            }
            else {
                // create face normal from vertices
                n = vb.minus(va).cross(vc.minus(va));
            }
        }
        
        return new STLTriangle(n.normalized(), va.plus(t), vb.plus(t), vc.plus(t));
    }
    
    @SuppressWarnings("Duplicates")
    @NotNull
    private static OBJFace[] tessellate(OBJFace polygon) {
        final int vertices = polygon.size();
        if (vertices < 3) return new OBJFace[0];
        if (vertices == 3) return new OBJFace[] {polygon};
        if (vertices == 4) {
            OBJTriplet
                a = polygon.getTriplet(0),
                b = polygon.getTriplet(1),
                c = polygon.getTriplet(2),
                d = polygon.getTriplet(3);
            return new OBJFace[] {
                new OBJFace(a, b, c),
                new OBJFace(c, d, a)};
        }
        throw new IllegalArgumentException("face must be triangle or quad");
    }
    
}
